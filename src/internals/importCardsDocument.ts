import {
  CardData,
  CardDataType,
  CardProperty,
  CardPropertyType,
  SocialForm,
  TheoryGroup,
} from "../models/PlayerData";
import path from "path";
import fs from "fs";
const CsvReadableStream = require("csv-reader");
const saveAs = path.join(process.cwd(), "src", "models", "ClassifiedCards.ts");

async function run() {
  const result = await extractDataPromise();
  fs.writeFileSync(
    saveAs,
    "//do not edit this files sinces it has been autogenerated by importCardsDocument.ts\n" +
      "import { CardData } from './PlayerData';\n" +
      "export const classifiedCards:Array<CardData> = " +
      JSON.stringify(result, null, 2) +
      ";"
  );
}
run();

async function extractDataPromise(): Promise<Array<CardData>> {
  const importFileTheory = path.join(
    process.cwd(),
    "docs",
    "Karten_Digitalisierung_DB - Theorie-Karten.csv"
  );
  const importFileEvent = path.join(
    process.cwd(),
    "docs",
    "Karten_Digitalisierung_DB - Ereignis-Karten.csv"
  );
  return new Promise<Array<CardData>>((resolve, reject) => {
    const result = new Array<CardData>();
    extractData(importFileTheory, "theory", (r) => {
      result.push(...r);
      extractData(importFileEvent, "event", (r) => {
        result.push(...r);
        resolve(result);
      });
    });
  });
}

function extractData(
  inputFile: string,
  cdt: CardDataType,
  onComplete: (r: Array<CardData>) => void
): void {
  const inputStream = fs.createReadStream(inputFile, "utf8");
  const result = new Array<CardData>();
  let didParseFirstRow = false;
  inputStream
    .pipe(
      new CsvReadableStream({
        parseNumbers: false,
        parseBooleans: false,
        trim: true,
      })
    )
    .on("data", function (row: Array<string>) {
      /*  First row is:    
                'Name',
                'Text',
                'Gruppe' or SocialForm,
                'Abbildung',
                'Werte',
                'Zeitkosten (von 4)',
                'Anzahl im Deck' */
      if (!didParseFirstRow) {
        didParseFirstRow = true;
        return;
      }
      if (row[0].length > 0) {
        const cd = parseRow(row, cdt);
        result.push(cd);
      }
    })
    .on("end", function () {
      onComplete(result);
    });
}

function classifySocialForm(socialFormName: string): SocialForm {
  if (socialFormName === "Solo") return "solo";
  if (socialFormName === "Gruppe") return "group";
  if (socialFormName === "Fachschaft") return "student-council";
  if (socialFormName === "Negativ-Solo") return "negative-solo";
  if (socialFormName === "Negativ-Gruppe") return "negative-group";
  throw new Error("Unknown social form name: " + socialFormName);
}
function classifyGroup(groupName: string): TheoryGroup {
  switch (groupName) {
    case "Dunkelgrün":
      return "darkgreen";
    case "Blau":
      return "blue";
    case "Gelb":
      return "yellow";
    case "Violet":
      return "violet";
    case "Rosa":
      return "rose";
    case "Grün":
      return "green";
    case "Grau":
      return "grey";
    case "Orange":
      return "orange";
  }
  throw new Error("Unknown group name: " + groupName);
}

function retrieveProperties(cardValues: string): Array<CardProperty> {
  const result = new Array<CardProperty>();
  const split = cardValues.split("/");
  for (const splitPart of split) {
    if (splitPart.length === 0) continue;
    if (splitPart.indexOf("0") >= 0) continue;
    if (splitPart.indexOf("?") >= 0) continue;

    let type: CardPropertyType;
    if (splitPart.startsWith("W") || splitPart.indexOf("Wissen") > -1) {
      //Wissen
      type = "knowledge";
    } else if (
      splitPart.startsWith("M") ||
      splitPart.indexOf("Motivation") > -1
    ) {
      //Motivation
      type = "motivation";
    } else if (
      splitPart.startsWith("Er") ||
      splitPart.indexOf("Erfahrung") > -1
    ) {
      //Erfahrung
      type = "experience";
    } else if (
      splitPart.startsWith("Em") ||
      splitPart.indexOf("Empowerment") > -1
    ) {
      //Erfahrung
      type = "empowerment";
    } else {
      throw new Error("Unknown property type: " + splitPart);
    }
    //extract nummeric value, include negative values
    const value = parseInt(splitPart.replace(/[^0-9-]/g, ""));
    result.push({ type, value });
  }
  return result;
}

function parseRow(row: Array<string>, cdt: CardDataType): CardData {
  const name = row[0];
  const text = row[1];
  const groupOrSocial = row[2];
  //const presentation = row[3];
  const values = row[4];
  const costs = row[5];
  const totalInDeck = row[6];

  const cd: CardData = {
    name: name,
    desc: text,
    type: cdt,
    properties: retrieveProperties(values),
    costs: parseInt(costs),
    totalInDeck: parseInt(totalInDeck),
  };
  if (cdt === "theory") {
    cd.group = classifyGroup(groupOrSocial);
  } else if (cdt === "event") {
    cd.socialForm = classifySocialForm(groupOrSocial);
  } else {
    throw new Error("Unknown card data type: " + cdt);
  }
  return cd;
}
